linux进程，线程以及调度
进程间通信
    进程通信(IPC)分为PIPE(管道)、Socket(套接字)和XSI(System_V)。XSI又分为msg(消息队列)、sem(信号量数组)和shm(共享内存)。这些手段都是用于进程间通信的，只有进程间通讯才需要借助第三方机制，线程之间通讯是不需要借助第三方机制，因为线程之间的地址空间是共享的。线程之间可以通过互斥量，死锁，唤醒，信号等来进行通讯。
    管道：
        管道是半双工的，也就是同一时间数据只能从一端流向另一段。就像水一样，两端水同时流入管道，那么数据就会乱
        管道的两端一端作为读端，一端是写端
        管道具有自适应的特点， 默认会适应速度比较慢的一方，管道被写满或读空时速度快的一方会自动阻塞


进程，线程创建与派生
    进程和线程的区别https://blog.csdn.net/qq_28351465/article/details/88950311
    Linux中无论是进程还是线程，只要是调度单元，都通过 struct task_struct表示。这也是为什么讲说进程和线程在内核相同的原因。
    struct task_struct有保存有关线程/进程中的一切信息，主要包括有线程/进程状态、与其他线程/进程关系、虚拟内存相关、日志相关、线程/进程限制等。该结构体定义在include/linux/sched.h文件中，感兴趣可以详细阅读
    那么，进程和线程在task_struct结构体中是否有标识上的不同？
    实际上，在struct task_struct中并没有明确的标识（枚举类型），区分该task是线程还是进程，不过可以通过pid和tgid简单判断当前task是哪种类型。
    在该结构体中如下段code所示，全局pid和tgid保存在task_struct结构体中。pid_t一般为int型，即可以同时使用不同标识的id。
    pid用于标识不同进程和线程。
    tgid用于标识线程组id，在同一进程中的所有线程具有同一tgid。tgid值等于进程第一个线程（主线程）的pid值。接着以CLONE_THREAD来调用clone建立的线程，都具有同样的tgid。(后文会详细描述创建过程)
    group_leader 线程组中的主线程的task_struct指针。
    总结 fork , vfork, clone
        由于执行fork()引入了 写时拷贝并且明确了子进程先执行，所以 vfork()的好处就仅限于不拷贝父进程的页表项mm_struct。vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行。
        vfork场景下父进程会先休眠，等唤醒子进程后，再唤醒父进程。
        这么做的好处是：由于子进程被创建出来，与父进程共享地址空间，且只读。只有在执行exec的创建新的内存映射时才会拷贝父进程的数据，来创建新的地址空间。如果此时，父进程还在执行，就有可能产生脏数据，或发生死锁。
        fork和vfork的区别：
            1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段
            2. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。
            3. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。
            4.当需要改变共享数据段中变量的值，则拷贝父进程。


    协程
        概念：
            协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

        协程和线程区别
            那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
            第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。



