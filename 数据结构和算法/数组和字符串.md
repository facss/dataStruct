# k sum 问题
## 1.两数和
给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

**示例:** 
给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]

**思路:**
数组没说有序没序，因此可以利用哈希来进行。初始化哈希表，接着查看一下哈希表中有没有该值，如果没有的话就将index作为value放入到map中，map中的key利用当前的数组值，value则记录下数组值的index，这样遍历一次之后，如果当前的值已经存在在哈希表中，那么就不再记录到哈希表中。
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        //解法1，双指针，不过前提需要先对数组进行排序
        vector<int> backup(nums.begin(),nums.end());
        sort(backup.begin(),backup.end());
        int len = backup.size();
        vector<int> res;
        int left = 0; 
        int right = len-1;
        while(left <len && right >=0) {
           int tmp = backup[left] + backup[right];
          if(tmp < target) {
                ++left;
            } else if (tmp > target) {
                --right;
            } else {
               break;
            }
        }
        if(left != len-1 && right != 0) {
              for(int i = 0;i < nums.size();++i) {
                    if(nums[i] == backup[left] || nums[i] == backup[right]) {
                        res.push_back(i);
                }
            }
        }     
        return res;
        //解法2，采用哈希表的方式，算法空间复杂度o(n),时间复杂度o(n)
        /*
        unordered_map<int,int> mp;
        vector<int> res;
        for(int i = 0;i < nums.size();++i) {
            int tmp = target - nums[i];
            if(mp.count(tmp)) {//如果存在就直接返回
                res.push_back(i);
                res.push_back(mp[tmp]);
                return res;
            } else {//不存在的话就把数据存进去
                mp[nums[i]] = i;
            }
        }
        return res;
        */
    }
};
```
## 2.三数和

## 3.四数和

## k sum求解

# 最长公共前缀