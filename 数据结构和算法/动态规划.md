实际最核心的问题在于怎么把题目归结为动态规划

    一旦知道了用动态规划，那么就需要在脑子里产生这样的概念，也就是步骤，其实动态规划无非就是利用历史记录来避免我们的重复计算，而这些历史记录，我们需要用一些变量来保存，一般是一维数组或者二维数组来保存。那么套路主要由四步：
        1）定义数组元素的含义，假设用一维数组dp[i]，此时最重要的点在于规定数组元素的含义，例如dp[i]代表了什么
        2) 找出数组元素之间的递推公式，其实就是归纳法，要计算dp[n]，需要用dp[n]=dp[n-1]+dp[n-2]，这个就是关系式，
        3）找到初始值，知道了初始值之后就可以推导得到后面的值
        4)最后举例遍历一下dp数组


基础问题
    斐波那契数列
        斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
        ｜ F(0) = 0，F(1) = 1,F(n) = F(n - 1) + F(n - 2)，其中 n > 1
        给你 n ，请计算 F(n) 。
        思路1：
        ｜ int fib(int N) {
        ｜     vector<int>dp(N+1);
        ｜     dp[0] = 0;
        ｜     dp[1] = 1;
        ｜     for(int i = 2;i <=N;++i) {
        ｜         dp[i] = dp[i-1] +dp[i-2];
        ｜     }
        ｜     return dp[N];
        ｜ ​}
        思路2：
        ｜ class Solution {
        ｜ public:
        ｜ int fib(int N) {
        ｜ if(N == 0) {
        ｜ return 0;
        ｜         }
        ｜ int last = 0;
        ｜ int result = 1;
        ｜ for(int i = 2;i <= N;++i) {
        ｜ int tmp = result;
        ｜             result += last;
        ｜             last = tmp;
        ｜         }
        ｜ return result;
        ｜     }
        ｜ };
        ｜ 

    70. 爬楼梯
        假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
        每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
        注意：给定 n 是一个正整数。
        示例 1：
        ｜ 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶
        示例 2：
        ｜ 输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶
        思路：
            1.确定dp数组以及下标的含义
            dp[i]： 爬到第i层楼梯，有dp[i]种方法
            2.确定递推公式
            如果可以推出dp[i]呢？
            从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。
            首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。
            还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。
            那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！
            所以dp[i] = dp[i - 1] + dp[i - 2] 。
            在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。
            这体现出确定dp数组以及下标的含义的重要性！
            3.dp数组如何初始化
            在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。
            那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。
            例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。
            但总有点牵强的成分。
            那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.
            其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。
            从dp数组定义的角度上来说，dp[0] = 0 也能说得通。
            需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。
            所以本题其实就不应该讨论dp[0]的初始化！
            我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。
            所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。
            4.确定遍历顺序
            从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的
            5.举例推导dp数组
            举例当n为5的时候，dp table（dp数组）应该是这样的

        思路1，
        ｜     int climbStairs(int n) {
        ｜         if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        ｜         vector dp(n + 1);
        ｜         dp[1] = 1;
        ｜         dp[2] = 2;
        ｜         for (int i = 3; i <= n; i++) { // 注意i是从3开始的
        ｜             dp[i] = dp[i - 1] + dp[i - 2];
        ｜         }
        ｜         return dp[n];
        ｜     }
        ｜ 
        思路2，优化一下空间，题解：
        ｜ int climbStairs(int n) {
        ｜ if(n == 0){
        ｜     return 1;
        ｜ }
        ｜ int last = 1;
        ｜ int result = 1;
        ｜ for(int i = 2;i <=n;++i) {
        ｜             int tmp = result;
        ｜             result += last;
        ｜             last = tmp;
        ｜         } 
        ｜     return result;
        ｜ }

    746. 使用最小花费爬楼梯
        数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
        每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
        请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。
        示例 1：
        ｜ 输入：cost = [10, 15, 20]输出：15解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。
        示例 2：
        ｜ 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
        ｜ 输出：6
        ｜ 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
        ｜ 
        ｜ 
        题解：
        ｜ int minCostClimbingStairs(vector<int>& cost) {
        ｜     int len = cost.size();
        ｜     if(len == 0) {
        ｜         return 0;
        ｜     }
        ｜     if(len == 1) {
        ｜         return cost[0];
        ｜     }
        ｜     int res[2000] = {0};
        ｜     res[0] = 0;
        ｜     res[1] = 0;
        ｜     for(int i = 2;i <= len ;++i) {
        ｜             res[i] = min(res[i-1]+cost[i-1],res[i-2]+cost[i-2]);
        ｜      }
        ｜     return res[len];
        ｜ }

    矩形的最短路径和
        给定一个，包含非负整数的 m x n 网格。请找出一条，从左上角到右下角的路径。使得路径上，所有数字总和为最小，每次只能向下，或者向右移动一步。
        输入:[[1,3,1],
              [1,5,1],
              [4,2,1]]
        输出: 7
        解释: 因为路径 1→3→1→1→1 的总和最小。
        思路：状态转移方程如下：
            dp[i][0] = dp[i-1][0] + grid[i][0];   i > 0,j = 0，边界条件
            dp[0][j] = dp[0][j-1] + grid[0][j];   i = 0,j > 0，边界条件
            dp[i][j] = min(dp[i-1][j],dp[i][j-1]) + grid[i][j], i >0,j > 0

        代码：
        ｜ int maxPathSum(vector>& grid) {
        ｜     int n = grid.size();
        ｜     int m = grid[0].size();
        ｜     vector> sum(n,vector(m,0));
        ｜     int i,j;
        ｜     sum[0][0] = grid[0][0];
        ｜     for(int i = 1;i < n;++i) {
        ｜         sum[i][0] = sum[i-1][0] + grid[i][0];
        ｜     }
        ｜     for(int j = 0;j < m;++j) {
        ｜         sum[0][j] = sum[0][j-1] + grid[0][j];
        ｜     }
        ｜     for(int i = 1;i < n;++i) {
        ｜         for(int j = 1;j 
        ｜             sum[i][j] = grid[i][j] + min(sum[i-1][j] ,sum [i][j-1]);
        ｜         }
        ｜     }
        ｜     return sum[i-1][j-1];
        ｜ }
        ｜ 

    62. 不同路径
        一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
        机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
        问总共有多少条不同的路径？
        示例 1：
        ｜ 输入：m = 3, n = 7输出：28
        **示例 2：
        ｜ 输入：m = 3, n = 2
        ｜ 输出：3
        ｜ 解释：
        ｜ 从左上角开始，总共有 3 条路径可以到达右下角。
        ｜ 1. 向右 -> 向下 -> 向下
        ｜ 2. 向下 -> 向下 -> 向右
        ｜ 3. 向下 -> 向右 -> 向下
        ｜ 
        示例 3：
        ｜ 输入：m = 7, n = 3输出：28
        示例 4：
        ｜ 输入：m = 3, n = 3输出：6
        思路：
        ｜ int uniquePaths(int m, int n) {
        ｜         vector<vector<int>>dp(m ,vector<int>(n ,0));
        ｜         //二维数组的初始化不能只有单个值，应该是某一维等于0的情况下的情况
        ｜         //例如i=0或j=0的时候的情况
        ｜         for(int i = 0;i < m;++i) {dp[i][0] = 1;}
        ｜         for(int i = 0;i < n;++i) {dp[0][i] = 1;}
        ｜         for(int i = 1;i < m; ++i) {
        ｜             for(int j = 1;j <n;++j) {
        ｜                 dp[i][j] = dp[i-1][j] + dp[i][j-1];
        ｜             }
        ｜         } 
        ｜         return dp[m - 1][n - 1];
        ｜     }

    63. 不同路径 II
        一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
        机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。
        现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
        网格中的障碍物和空位置分别用 1 和 0 来表示。
        示例 1：
        ｜ 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
        ｜ 输出：2
        ｜ 解释：
        ｜ 3x3 网格的正中间有一个障碍物。
        ｜ 从左上角到右下角一共有 2 条不同的路径：
        ｜ 1. 向右 -> 向右 -> 向下 -> 向下
        ｜ 2. 向下 -> 向下 -> 向右 -> 向右
        ｜ 
        示例 2：
        ｜ 输入：obstacleGrid = [[0,1],[0,0]]输出：1
        思路：
        ｜ int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        ｜     int row = obstacleGrid.size();
        ｜     int col = obstacleGrid[0].size();
        ｜     vector<vector<int>> dp(row,vector<int>(col,0));
        ｜     for(int i = 0; i < row && obstacleGrid[i][0] == 0;++i) {
        ｜         dp[i][0] = 1;
        ｜     }
        ｜     for(int i = 0; i < col && obstacleGrid[0][i] == 0;++i) {
        ｜         dp[0][i] = 1;
        ｜     }
        ｜     for(int i = 1;i < row;++i) {
        ｜     for(int j = 1;j < col;++j) {
        ｜         if(obstacleGrid[i][j] == 1 ) {
        ｜               continue;
        ｜                }
        ｜           dp[i][j] = dp[i][j-1] + dp[i-1][j];             
        ｜             }
        ｜         }
        ｜     return dp[row -1][col -1];
        ｜     }

    343. 整数拆分
        给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
        示例 1:
        ｜ 输入: **2输出: 1解释: **2 = 1 + 1, 1 × 1 = 1。
        示例 2:
        ｜ 输入: **10输出: 36解释: **10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
        思路1：j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
        也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。
        如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。
        所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});
        那么在取最大值的时候，为什么还要比较dp[i]呢？
        因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。
        题解代码：
        ｜ int integerBreak(int n) {
        ｜         vector<int>dp(n + 1,0);
        ｜         dp[2] = 1;
        ｜         //核心要点是拆分出i之后，再对i进行拆分，这样就是从i * (i-j)这两个元素
        ｜         //或者i * dp(i-j),这里dp[i-j]其实就是接着对i-j进行拆分
        ｜         for(int i = 3;i <=n;++i) {//i其实应从2开始，但是2的结果已经是作为初值，因此这里从3开始
        ｜         for(int j = 1;j < i-1;++j) {//j表示拆分出来的数字j,dp[j]表示拆解出j后的最大乘积
        ｜             dp[i] = max(dp[i], max((i-j) * j,dp[i-j] * j));
        ｜             }
        ｜         }
        ｜ return dp[n];
        ｜     }

    乘积最大连续子数组
        题目：
        输入一个整形数组，数组里有正数也有负数。数组中连续的一个，或多个整数组成一个子数组，每个子数组都有一个和。求所有子数组的和的最大值。
        例如数组：arr[]={1, 2, 3, -2, 4, -3 } 最大子数组为 {1, 2, 3, -2, 4} 和为8。
        思路：fmax(i) 表示，以第 i 个元素结尾的，乘积最大子数组的乘积，fmin(i) 表示，以第 i 个元素结尾的，乘积最小子数组的乘积。这里分为最大和最小是因为数组可能存在负数，最大值乘以负数变成较小值，最小值乘以一个负数也可能变成最大值。
        比较方程是：当前数乘以上一个最大值，当前值，当前数乘以上一个最小值。这三者比较，其中的最大值，就是我们要的最大值。
        同样，每次也要把最小值计算出来，方式同上。
        题解：


    划分数组为两个相等的子集
        题目：输入：[1, 5, 11, 5]， 输出：[1, 5, 5]和[11]
        思路：
            相对数组中每个数求dp，最后就会找到dp[target]是否为true。
            如果 dp[j - nums[i]] 为true的，说明可以组成 j-nums[i]这个数，再加上nums[i]，就可以组成数字j。
            当j = target是同样道理，要想找到dp[target]为true，就找到数组中，几个值的和为target时，对应下标的dp值为true，这样反推dp[target]为true。

        代码：
        ｜ bool canPartition(vector& nums) {
        ｜     int sum = 0;
        ｜         for(int i = 0;i < nums.size();++i) {
        ｜             sum += nums[i];
        ｜         }
        ｜         if(sum % 2 != 0) {//如果是奇数，那么就不可能有结果，直接返回0
        ｜             return 0;
        ｜         }
        ｜         int target = sum / 2;
        ｜         vector dp(target + 1,0);
        ｜         dp[0] = 1;//边界条件
        ｜         for(int i = 0;i < nums.size();++i) {
        ｜             for(int j = target;j >= nums.size[i];--j) {
        ｜                     dp[j] = dp[j] || dp[j - nums[i]]
        ｜                 }
        ｜ 
        ｜         }
        ｜         return dp[target];
        ｜ 
        ｜ }
        ｜ 

    96. 不同的二叉搜索树
        给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
        示例 1：
        ｜ 输入：n = 3输出：5
        示例 2：
        ｜ 输入：n = 1输出：1
        题解：
        ｜ class Solution {
        ｜ public:
        ｜ int numTrees(int n) {
        ｜         vector<int> dp(n+1);
        ｜ dp[0]=1;dp[1]=1;
        ｜ for(int i=2;i<=n;++i)
        ｜ for(int j=1;j<=i;++j)
        ｜ dp[i]+=dp[j-1]*dp[i-j];
        ｜ return dp[n];
        ｜     }
        ｜ };
        ｜ 

    300.最长递增子序列
        给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
        子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
            思路：dp[i]表示以a[i]这个元素为结尾的最长递增子序列长度，例如想求 dp[5] 的值，也就是想求以 nums[5] 为结尾，其最长递增子序列。nums[5] = 3，既然是递增子序列。我们只要找到，前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成新的递增子序列，而且这个新的子序列长度加一。

        题解：
        ｜ int lengthOfLIS(vector& nums) {
        ｜     int len = nums.size();
        ｜         if(len == 0) {
        ｜             return 0;
        ｜         }
        ｜         vector dp(len,1);
        ｜         for(int i = 0;i < len;++i) {
        ｜             for(int j = 0;j < i;++j) {
        ｜                     if(a[j] < a[i]) {
        ｜                             dp[i] = max(dp[i],dp[j] + 1);
        ｜                         }
        ｜                 }
        ｜         }
        ｜         int res= 0;
        ｜         for(int i = 0;i < n;++i) {
        ｜             res = max(res,dp[i]);
        ｜         }
        ｜         return res;
        ｜ }
        ｜ 


