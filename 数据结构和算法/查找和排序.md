# 查找

# 排序
<details>
<summary>快速排序</summary>

    快速排序的基本思想，通过一趟排序将待排记录分割成两部分，其中一部分记录的关键字均比另一部分的关键字小，则可以分别将这两部分继续进行排序，以达到整个序列有序.（默认一般用第一个元素作为基准）

**算法描述**
    快速排序适用分治法来把一个串分为两个子串。具体算法描述如下：
        从数列中跳出一个元素，称为“基准”
        重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区操作；
         递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。
**图解**

**算法：**

```
 class Solution {
public: 
     vector<int> sortArray(vector<int> nums) { 
         int len = num,s.size() - 1;
         quickSort(nums,0,len - 1);
         return nums;
     }
     void quickSort (vector<int> nums, int low, int high) {
         if (low < high) {
             int index = partition(nums,low,high);//通过一次遍历得到排序，index是下标
             quickSort(nums,low,index-1);//分治求解
             quickSort(nums,index+1,high);
         }    
     }
     //利用填坑法
     int partition (vector<int> nums, int low, int high) {
        int pivot = nums[low];
        while (low < high) {
            //移动high指针
            while (low < high && nums[high] >= pivot) {
                hight--;
            }
            //填坑
            if (low < high) nums[low] = nums[high];
            while (low < high && nums[low] <= pivot) {
                low++;
            }
            //填坑
            if (low < high) nums[high] = nums[low];
        }
        //基准数放到合适的位置
        nums[low] = pivot;
        return low;
     }   
 }
```